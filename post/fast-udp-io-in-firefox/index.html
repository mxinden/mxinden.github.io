<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Fast UDP I/O for Firefox in Rust | Max Inden</title>
<meta name="keywords" content="tech, quic, firefox, rust, networking">
<meta name="description" content="Motivation
Around 20% of Firefox&rsquo;s HTTP traffic today uses HTTP/3, which runs over QUIC, which in turn runs over UDP.
This translates to substantial UDP I/O activity.
Firefox uses NSPR for most of its network I/O.
When it comes to UDP I/O, NSPR only offers a limited set of dated APIs, most relevant here PR_SendTo and PR_RecvFrom, wrappers around POSIX&rsquo;s sendto and recvfrom.
The N in NSPR stands for Netscape, giving you a hint of its age.">
<meta name="author" content="Max Inden">
<link rel="canonical" href="https://max-inden.de/post/fast-udp-io-in-firefox/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://max-inden.de/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://max-inden.de/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://max-inden.de/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://max-inden.de/apple-touch-icon.png">
<link rel="mask-icon" href="https://max-inden.de/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://max-inden.de/post/fast-udp-io-in-firefox/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Fast UDP I/O for Firefox in Rust" />
<meta property="og:description" content="Motivation
Around 20% of Firefox&rsquo;s HTTP traffic today uses HTTP/3, which runs over QUIC, which in turn runs over UDP.
This translates to substantial UDP I/O activity.
Firefox uses NSPR for most of its network I/O.
When it comes to UDP I/O, NSPR only offers a limited set of dated APIs, most relevant here PR_SendTo and PR_RecvFrom, wrappers around POSIX&rsquo;s sendto and recvfrom.
The N in NSPR stands for Netscape, giving you a hint of its age." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://max-inden.de/post/fast-udp-io-in-firefox/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2025-09-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2025-09-14T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Fast UDP I/O for Firefox in Rust"/>
<meta name="twitter:description" content="Motivation
Around 20% of Firefox&rsquo;s HTTP traffic today uses HTTP/3, which runs over QUIC, which in turn runs over UDP.
This translates to substantial UDP I/O activity.
Firefox uses NSPR for most of its network I/O.
When it comes to UDP I/O, NSPR only offers a limited set of dated APIs, most relevant here PR_SendTo and PR_RecvFrom, wrappers around POSIX&rsquo;s sendto and recvfrom.
The N in NSPR stands for Netscape, giving you a hint of its age."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://max-inden.de/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Fast UDP I/O for Firefox in Rust",
      "item": "https://max-inden.de/post/fast-udp-io-in-firefox/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Fast UDP I/O for Firefox in Rust",
  "name": "Fast UDP I\/O for Firefox in Rust",
  "description": "Motivation Around 20% of Firefox\u0026rsquo;s HTTP traffic today uses HTTP/3, which runs over QUIC, which in turn runs over UDP. This translates to substantial UDP I/O activity.\nFirefox uses NSPR for most of its network I/O. When it comes to UDP I/O, NSPR only offers a limited set of dated APIs, most relevant here PR_SendTo and PR_RecvFrom, wrappers around POSIX\u0026rsquo;s sendto and recvfrom. The N in NSPR stands for Netscape, giving you a hint of its age.\n",
  "keywords": [
    "tech", "quic", "firefox", "rust", "networking"
  ],
  "articleBody": "Motivation Around 20% of Firefox’s HTTP traffic today uses HTTP/3, which runs over QUIC, which in turn runs over UDP. This translates to substantial UDP I/O activity.\nFirefox uses NSPR for most of its network I/O. When it comes to UDP I/O, NSPR only offers a limited set of dated APIs, most relevant here PR_SendTo and PR_RecvFrom, wrappers around POSIX’s sendto and recvfrom. The N in NSPR stands for Netscape, giving you a hint of its age.\nOperating systems have evolved since. Many offer multi-message APIs like sendmmsg and recvmmsg. Some offer segmentation offloading like GSO (Generic Segmentation Offload) and GRO (Generic Receive Offload). Each of these promise significant performance improvements for UDP I/O.\nCan Firefox benefit from replacing its aging UDP I/O stack with modern system calls?\nOverview This project began in mid-2024 with the goal of rewriting Firefox’s QUIC UDP I/O stack using modern system calls across all supported operating systems. Beyond performance improvements, we wanted to increase security by using a memory-safe language to do UDP I/O. Firefox’s QUIC state machine itself is implemented in Rust already. We thereby chose Rust for this project as well, giving us both increased security and easy integration with the existing QUIC codebase.\nInstead of starting from scratch, we built on top of quinn-udp, the UDP I/O library of the Quinn project, a QUIC implementation in Rust. This sped up our development efforts significantly. Big thank you to the Quinn project. Operating system calls are complex, with a myriad of idiosyncrasies, especially across versions. Firefox is multi-platform, focusing on Windows, Android, MacOS and Linux as tier 1. The main complexity though stems from Firefox supporting ancient versions of each of them, e.g. Android 5.\nOne year later, i.e., mid 2025, this project is now rolling out to the majority of Firefox users. Performance benchmark results are promising. In extreme cases, on purely CPU bound benchmarks, we’re seeing a jump from \u003c 1Gbit/s to 4 Gbit/s. Looking at CPU flamegraphs, the majority of CPU time is now spent in I/O system calls and cryptography code.\nBelow are the many improvements we were able to land, plus the ones we weren’t. I hope other projects in need of fast UDP I/O can benefit from our work. To make their lifes easier, below I am documenting the many learnings we made.\nThe basics To understand the improvements, it’s helpful to first examine how UDP I/O traditionally works and how modern optimizations change this picture.\nSingle datagram Previously Firefox would send (and receive) single UDP datagrams to (and from) the OS via sendto (and recvfrom) system call family. The OS would send (and receive) that UDP datagram to (and from) the network interface card (NIC). The NIC would send (and receive) it to (and from) the Internet.\nThus each datagram would require leaving user space which is cheap for one UDP datagram, but expensive when sending at say a 500 Mbit/s rate. In addition all user space and kernel space overhead independent of the number of bytes sent and received, is paid per datagram, i.e. per \u003c 1500 bytes.\n+----------------------+ | Firefox | | +-----------+ | | | QUIC | | | +-----------+ | +----------------------+ | [ datagram ] | === User / Kernel === | [ datagram ] | +----------------------+ | OS | +----------------------+ | [ datagram ] | +----------------------+ | NIC | +----------------------+ | [ datagram ] | +----------------------+ | Internet | +----------------------+ Batch of datagrams Instead of sending a single datagram at a time, some operating systems nowadays offer multi-message system call families, e.g. on Linux sendmmsg and recvmmsg. The idea is simple. Send and receive multiple UDP datagrams at once, save on the costs that are independent of the number of bytes sent and received.\n+--------------------------+ | Firefox | | +-----------+ | | | QUIC | | | +-----------+ | +--------------------------+ | [ datagram, datagram, datagram ] | ===== User / Kernel ===== | [ datagram, datagram, datagram ] | +--------------------------+ | OS | +--------------------------+ | [ datagram, datagram, datagram ] | +--------------------------+ | NIC | +--------------------------+ | [ datagram, datagram, datagram ] | +--------------------------+ | Internet | +--------------------------+ Single large segmented datagram Some modern operating systems and network interface cards also support system call families with UDP segmentation offloading, e.g. GSO and GRO on Linux. Instead of sending multiple UDP datagrams in a batch, it enables the application to send a single large UDP datagram, i.e. larger than the Maximum Transmission Unit, to the kernel. Next, either the kernel, but really ideally the network interface card, will segment it into multiple smaller packets, add a header to each and calculates the UDP checksum. The reverse happens on the receive path, where multiple incoming packets can be coalesced into a single large UDP datagram delivered to the application all at once.\n+------------------------------+ | Firefox | | +-----------+ | | | QUIC | | | +-----------+ | +------------------------------+ | [ large segmented datagram ] | ====== User / Kernel ====== | [ large segmented datagram ] | +------------------------------+ | OS | +------------------------------+ | [ large segmented datagram ] | +------------------------------+ | NIC | +------------------------------+ | [ datagram, datagram, datagram ] | +------------------------------+ | Internet | +------------------------------+ Note: Unfortunately, Wireshark does not yet support GSO, making network-level debugging more challenging when these optimizations are active.\nFor performance analysis of these different approaches, Cloudflare’s comprehensive study provides excellent benchmarks and detailed explanations.\nReplacing NSPR in Firefox Batching and segmentation offloading aside for now, first step in the project was to replace usage of NSPR with quinn-udp, still sending and receiving one UDP datagram at a time. We updated the Mozilla QUIC client and server test implementation, then integrated quinn-udp into Firefox itself.\nNext we rewrote the UDP datagram processing pipeline in the Mozilla QUIC implementation to send and receive batches of datagrams. This is done in a way, such that we can leverage both the multi-message style system calls, as well as the segmentation offloading style, if available. We added this along with various other I/O improvements, e.g. Lars added in-place en-/decryption. Going into detail here is better done in a separate blog post. Let’s focus on UDP I/O here.\nSo far so good. This was the easy part. Up next, the edge cases by platform.\nPlatform details Windows Windows offers WSASendMsg and WSARecvMsg to send and receive a single UDP datagram. That UDP datagram can either be a classic MTU size datagram, or a large segmented datagram. For the latter, what Linux calls GSO and GRO, Windows call USO and URO. As described above, we started off rolling out quinn-udp using single-datagram system calls only. This went without issues on Windows.\nNext we tested WSARecvMsg with URO, i.e. receiving a batch of inbound datagrams as a single large segmented datagram, but got the following bug report:\nfosstodon.org doesn’t load with network.http.http3.use_nspr_for_io=false on ARM64 Windows\nfosstodon is a Mastodon server. It is hosted behind the CDN provider Fastly. Fastly is a heavy user of Linux’s GSO, i.e. sends larger UDP datagram trains, perfect to be coalesced into a single large segmented UDP datagram when Firefox receives it. Why would Window’s URO prevent Firefox from loading the site?\nAfter many hours of back and forth with the reporter, luckily a Mozilla employee as well, I ended up buying the exact same laptop, same color, in a desperate attempt to reproduce the issue. Without much luck at first, I eventually needed a Linux command line tool, thus installed WSL, and to my surprise, that triggered the bug (reproducer). Turns out, on Windows on ARM, with WSL enabled, a WSARecvMsg call with URO would not return a segment size, thus Firefox was unable to differentiate a single datagram, from a single segmented datagram. QUIC short header packets don’t carry a length, thus there is no way to tell where one QUIC packet ends and another starts, leading to the above page load failures.\nWe have been in touch with Microsoft since. No progress thus far. Thereby we are keeping URO on Windows disabled in Firefox for now.\nAfter URO we started using WSASendMsg USO, i.e. sending a single large segmented datagram per system call. But this too we rolled back quickly, seeing increased packet loss on Firefox Windows installations. In addition, we have at least one report of a user, seeing their network driver crash due to Firefox’s usage of USO. More debugging needed.\nMacOS The transition on MacOS from NSPR to quinn-udp for HTTP/3 QUIC UDP I/O involved switching from the system calls sendto and recvfrom to the system calls sendmsg and recvmsg. As with Windows, no issues on this first step, ignoring one report where MacOS 10.15 might be seeing IP packets other than v4 and v6 (fixed since).\nUnfortunately MacOS does not offer UDP segmentation offloading, neither on the send, nor on the receive side. What it does offer though are two undocumented system calls, namely sendmsg_x and recvmsg_x, allowing a user to send and receive batches of UDP datagrams at once. Lars from Mozilla added it to quinn-udp, exposed behind the fast-apple-datapath feature flag, off by default. After multiple iterations with smaller bugfixes (#2154, #2214, #2216 …) we decided to not ship it to users, not knowing how MacOS would behave, in case Apple ever decides to remove it, but with Firefox still calling it.\nLinux Linux provides the most comprehensive and mature UDP optimization support, offering both multi-message APIs (sendmmsg/recvmmsg) and segmentation offloading (GSO/GRO). The quinn-udp library makes a deliberate choice to prioritize GSO over sendmmsg for transmission, as GSO typically provides superior performance with diminishing returns when both techniques are combined. Thus far, this has proven the right choice for Firefox as well.\nIn addition to segmentation offloading being superior in the first place, Firefox uses one UDP socket per connection in order to improve privacy. As each socket gets its own source port it is harder to correlate connections. Why is this relevant here? GSO (and GRO) can only segment (and coalesce) datagrams from the same 4-tuple (src IP, src port, dst IP, dst port), sendmmsg and recvmmsg on the other hand can send and receive across 4-tuples. Given that Firefox uses one socket per connection, it cannot make use of that distinct benefit of sendmmsg (and recvmmsg), making segmentation offloading yet again the obvious choice for Firefox.\nIgnoring minor changes required to Firefox’s optional network sandboxing, and an additional at runtime GSO support check, replacing Firefox’s QUIC UDP I/O stack on Linux has been without issues, now enjoying all the benefits of segmentation offloading.\nAndroid During the time of this project I learned quickly that (a) Android is not Linux and (b) that Firefox still supports Android 5, …, on x86 (32 bit).\nOn x86, Android dispatches advanced socket calls through socketcall system call instead of calling e.g. sendmsg directly. In addition Android has various default seccomp filters, crashing an app when e.g. not going through the required socketcall system call. The combination of the two did cost me a couple of days, resulting in this (basically single line) change in quinn-udp.\nOn Android API level 25 and below, calling sendmsg with an ECN bit set results in an error EINVAL. quinn-udp will now simply retry on EINVAL disabling various optional settings (e.g. ECN) on the second attempt.\nGreat benefit of the Quinn community is that Firefox will benefit from any improvements made to quinn-udp. For example this excellent find by Thomas where Android in some cases would complain if we did a GSO with a single segment only.\nExplicit congestion notifications (ECN) With Firefox using modern system calls across all major operating systems, a nice additional benefit is the ability to send and receive ancillary data like IP ECN. This too came with some minor surprises, but QUIC ECN in Firefox is well on its way now. Firefox Nightly telemetry shows around 50% of all QUIC connections running on ECN outbound capable paths. With L4S and thus ECN becoming more and more relevant in today’s Internet, this is a great step forward.\nSummary We successfully replaced Firefox’s QUIC UDP I/O stack with a modern memory-safe implementation using quinn-udp. Instead of limited and dated system calls like sendto and recvfrom, Firefox now uses modern OS specific system calls across all major platforms, resulting in HTTP/3 QUIC throughput improvements when CPU bound, and enabling QUIC ECN support across all major platforms. Some OS specific optimizations still need more work, e.g. USO and URO on Windows. That said, especially given QUIC’s growing adoption and thus increased UDP usage, I am optimistic that OS and driver support will continue to improve.\n",
  "wordCount" : "2099",
  "inLanguage": "en",
  "datePublished": "2025-09-14T00:00:00Z",
  "dateModified": "2025-09-14T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Max Inden"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://max-inden.de/post/fast-udp-io-in-firefox/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Max Inden",
    "logo": {
      "@type": "ImageObject",
      "url": "https://max-inden.de/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://max-inden.de/" accesskey="h" title="Max Inden (Alt + H)">Max Inden</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://max-inden.de/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://max-inden.de/resume" title="Resume">
                    <span>Resume</span>
                </a>
            </li>
            <li>
                <a href="https://max-inden.de/readings" title="Readings">
                    <span>Readings</span>
                </a>
            </li>
            <li>
                <a href="https://max-inden.de/post/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://max-inden.de/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://max-inden.de/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Fast UDP I/O for Firefox in Rust
    </h1>
    <div class="post-meta"><span title='2025-09-14 00:00:00 +0000 UTC'>September 14, 2025</span>&nbsp;·&nbsp;Max Inden

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#motivation" aria-label="Motivation">Motivation</a></li>
                <li>
                    <a href="#overview" aria-label="Overview">Overview</a></li>
                <li>
                    <a href="#the-basics" aria-label="The basics">The basics</a><ul>
                        
                <li>
                    <a href="#single-datagram" aria-label="Single datagram">Single datagram</a></li>
                <li>
                    <a href="#batch-of-datagrams" aria-label="Batch of datagrams">Batch of datagrams</a></li>
                <li>
                    <a href="#single-large-segmented-datagram" aria-label="Single large segmented datagram">Single large segmented datagram</a></li></ul>
                </li>
                <li>
                    <a href="#replacing-nspr-in-firefox" aria-label="Replacing NSPR in Firefox">Replacing NSPR in Firefox</a></li>
                <li>
                    <a href="#platform-details" aria-label="Platform details">Platform details</a><ul>
                        
                <li>
                    <a href="#windows" aria-label="Windows">Windows</a></li>
                <li>
                    <a href="#macos" aria-label="MacOS">MacOS</a></li>
                <li>
                    <a href="#linux" aria-label="Linux">Linux</a></li>
                <li>
                    <a href="#android" aria-label="Android">Android</a></li></ul>
                </li>
                <li>
                    <a href="#explicit-congestion-notifications-ecn" aria-label="Explicit congestion notifications (ECN)">Explicit congestion notifications (ECN)</a></li>
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="motivation">Motivation<a hidden class="anchor" aria-hidden="true" href="#motivation">#</a></h2>
<p>Around 20% of Firefox&rsquo;s HTTP traffic today uses HTTP/3, which runs over QUIC, which in turn runs over UDP.
This translates to substantial UDP I/O activity.</p>
<p>Firefox uses <a href="https://www-archive.mozilla.org/projects/nspr/">NSPR</a> for most of its network I/O.
When it comes to UDP I/O, NSPR only offers a limited set of dated APIs, most relevant here <a href="https://firefox-source-docs.mozilla.org/nspr/reference/pr_sendto.html"><code>PR_SendTo</code></a> and <a href="https://firefox-source-docs.mozilla.org/nspr/reference/pr_recvfrom.html"><code>PR_RecvFrom</code></a>, wrappers around POSIX&rsquo;s <code>sendto</code> and <code>recvfrom</code>.
The N in NSPR stands for Netscape, giving you a hint of its age.</p>
<p>Operating systems have evolved since.
Many offer multi-message APIs like <code>sendmmsg</code> and <code>recvmmsg</code>.
Some offer segmentation offloading like GSO (Generic Segmentation Offload) and GRO (Generic Receive Offload).
Each of these promise significant performance improvements for UDP I/O.</p>
<p>Can Firefox benefit from replacing its aging UDP I/O stack with modern system calls?</p>
<h2 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h2>
<p>This project began in mid-2024 with the goal of rewriting Firefox&rsquo;s QUIC UDP I/O stack using modern system calls across all supported operating systems.
Beyond performance improvements, we wanted to increase security by using a memory-safe language to do UDP I/O.
Firefox&rsquo;s QUIC state machine itself is implemented in Rust already.
We thereby chose Rust for this project as well, giving us both increased security and easy integration with the existing QUIC codebase.</p>
<p>Instead of starting from scratch, we built on top of <a href="https://github.com/quinn-rs/quinn/tree/main/quinn-udp"><code>quinn-udp</code></a>, the UDP I/O library of the Quinn project, a QUIC implementation in Rust.
This sped up our development efforts significantly.
Big thank you to the Quinn project.
Operating system calls are complex, with a myriad of idiosyncrasies, especially across versions.
Firefox is multi-platform, focusing on Windows, Android, MacOS and Linux as <a href="https://firefox-source-docs.mozilla.org/build/buildsystem/supported-configurations.html#supported-build-targets">tier 1</a>.
The main complexity though stems from Firefox supporting ancient versions of each of them, e.g.
Android 5.</p>
<p>One year later, i.e., mid 2025, this project is now rolling out to the majority of Firefox users.
Performance benchmark results are promising.
In extreme cases, on purely CPU bound benchmarks, we&rsquo;re seeing a jump from &lt; 1Gbit/s <a href="https://github.com/mozilla/neqo/actions/workflows/bench.yml">to 4 Gbit/s</a>.
Looking at CPU flamegraphs, the majority of CPU time is now spent in I/O system calls and cryptography code.</p>
<p>Below are the many improvements we were able to land, plus the ones we weren&rsquo;t.
I hope other projects in need of fast UDP I/O can benefit from our work.
To make their lifes easier, below I am documenting the many learnings we made.</p>
<h2 id="the-basics">The basics<a hidden class="anchor" aria-hidden="true" href="#the-basics">#</a></h2>
<p>To understand the improvements, it&rsquo;s helpful to first examine how UDP I/O traditionally works and how modern optimizations change this picture.</p>
<h3 id="single-datagram">Single datagram<a hidden class="anchor" aria-hidden="true" href="#single-datagram">#</a></h3>
<p>Previously Firefox would send (and receive) single UDP datagrams to (and from) the OS via <code>sendto</code> (and <code>recvfrom</code>) system call family.
The OS would send (and receive) that UDP datagram to (and from) the network interface card (NIC).
The NIC would send (and receive) it to (and from) <em>the Internet</em>.</p>
<p>Thus each datagram would require leaving user space which is cheap for one UDP datagram, but <a href="/post/2020-06-19-latencies/">expensive when sending at say a 500 Mbit/s rate</a>.
In addition all user space and kernel space overhead independent of the number of bytes sent and received, is paid per datagram, i.e. per &lt; 1500 bytes.</p>
<pre tabindex="0"><code>    +----------------------+
    |       Firefox        |
    |    +-----------+     |
    |    |   QUIC    |     |
    |    +-----------+     |
    +----------------------+
              |
         [ datagram ]
              |
    === User / Kernel ===
              |
         [ datagram ]
              |
    +----------------------+
    |         OS           |
    +----------------------+
              |
         [ datagram ]
              |
    +----------------------+
    |         NIC          |
    +----------------------+
              |
         [ datagram ]
              |
    +----------------------+
    |      Internet        |
    +----------------------+
</code></pre><h3 id="batch-of-datagrams">Batch of datagrams<a hidden class="anchor" aria-hidden="true" href="#batch-of-datagrams">#</a></h3>
<p>Instead of sending a single datagram at a time, some operating systems nowadays offer multi-message system call families, e.g. on Linux <code>sendmmsg</code> and <code>recvmmsg</code>.
The idea is simple.
Send and receive multiple UDP datagrams at once, save on the costs that are independent of the number of bytes sent and received.</p>
<pre tabindex="0"><code>    +--------------------------+
    |         Firefox          |
    |      +-----------+       |
    |      |   QUIC    |       |
    |      +-----------+       |
    +--------------------------+
                  |
  [ datagram, datagram, datagram ]
                  |
    ===== User / Kernel =====
                  |
  [ datagram, datagram, datagram ]
                  |
    +--------------------------+
    |           OS             |
    +--------------------------+
                  |
  [ datagram, datagram, datagram ]
                  |
    +--------------------------+
    |           NIC            |
    +--------------------------+
                  |
  [ datagram, datagram, datagram ]
                  |
    +--------------------------+
    |        Internet          |
    +--------------------------+
</code></pre><h3 id="single-large-segmented-datagram">Single large segmented datagram<a hidden class="anchor" aria-hidden="true" href="#single-large-segmented-datagram">#</a></h3>
<p>Some modern operating systems and network interface cards also support system call families with UDP segmentation offloading, e.g. <code>GSO</code> and <code>GRO</code> on Linux.
Instead of sending multiple UDP datagrams in a batch, it enables the application to send a single large UDP datagram, i.e. larger than the Maximum Transmission Unit, to the kernel.
Next, either the kernel, but really ideally the network interface card, will segment it into multiple smaller packets, add a header to each and calculates the UDP checksum.
The reverse happens on the receive path, where multiple incoming packets can be coalesced into a single large UDP datagram delivered to the application all at once.</p>
<pre tabindex="0"><code>    +------------------------------+
    |           Firefox            |
    |        +-----------+         |
    |        |   QUIC    |         |
    |        +-----------+         |
    +------------------------------+
                    |
      [ large segmented datagram ]
                    |
      ====== User / Kernel ======
                    |
      [ large segmented datagram ]
                    |
    +------------------------------+
    |             OS               |
    +------------------------------+
                    |
      [ large segmented datagram ]
                    |
    +------------------------------+
    |             NIC              |
    +------------------------------+
                    |
    [ datagram, datagram, datagram ]
                    |
    +------------------------------+
    |          Internet            |
    +------------------------------+
</code></pre><p><em>Note: Unfortunately, <a href="https://gitlab.com/wireshark/wireshark/-/issues/19109">Wireshark does not yet support GSO</a>, making network-level debugging more challenging when these optimizations are active.</em></p>
<p>For performance analysis of these different approaches, <a href="https://blog.cloudflare.com/accelerating-udp-packet-transmission-for-quic/">Cloudflare&rsquo;s comprehensive study</a> provides excellent benchmarks and detailed explanations.</p>
<h2 id="replacing-nspr-in-firefox">Replacing NSPR in Firefox<a hidden class="anchor" aria-hidden="true" href="#replacing-nspr-in-firefox">#</a></h2>
<p>Batching and segmentation offloading aside for now, first step in the project was to replace usage of NSPR with quinn-udp, still sending and receiving one UDP datagram at a time.
We updated the <a href="https://github.com/mozilla/neqo/pull/1604">Mozilla QUIC client and server test implementation</a>, then <a href="https://phabricator.services.mozilla.com/D216308">integrated quinn-udp into Firefox itself</a>.</p>
<p>Next we rewrote the UDP datagram processing pipeline in the Mozilla QUIC implementation to <a href="https://github.com/mozilla/neqo/pull/2184">send</a> and <a href="https://github.com/mozilla/neqo/pull/2184">receive</a> batches of datagrams.
This is done in a way, such that we can leverage both the multi-message style system calls, as well as the segmentation offloading style, if available.
We added this along with various other I/O improvements, e.g. Lars added <a href="https://github.com/mozilla/neqo/pull/2385">in-place en-/decryption</a>.
Going into detail here is better done in a separate blog post.
Let&rsquo;s focus on UDP I/O here.</p>
<p>So far so good.
This was the easy part.
Up next, the edge cases by platform.</p>
<h2 id="platform-details">Platform details<a hidden class="anchor" aria-hidden="true" href="#platform-details">#</a></h2>
<h3 id="windows">Windows<a hidden class="anchor" aria-hidden="true" href="#windows">#</a></h3>
<p>Windows offers <a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg?redirectedfrom=MSDN"><code>WSASendMsg</code></a> and <a href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms741687(v=vs.85)"><code>WSARecvMsg</code></a> to send and receive a single UDP datagram.
That UDP datagram can either be a classic MTU size datagram, or a large segmented datagram.
For the latter, what Linux calls <code>GSO</code> and <code>GRO</code>, Windows call <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/network/udp-segmentation-offload-uso-"><code>USO</code></a> and <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/network/udp-rsc-offload"><code>URO</code></a>.
As described above, we started off rolling out quinn-udp using single-datagram system calls only.
This went without issues on Windows.</p>
<p>Next we tested <code>WSARecvMsg</code> with <code>URO</code>, i.e. receiving a batch of inbound datagrams as a single large segmented datagram, but got <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1916558">the following bug report</a>:</p>
<blockquote>
<p>fosstodon.org doesn&rsquo;t load with network.http.http3.use_nspr_for_io=false on ARM64 Windows</p></blockquote>
<p>fosstodon is a Mastodon server.
It is hosted behind the CDN provider Fastly.
Fastly is a heavy user of Linux&rsquo;s GSO, i.e. sends larger UDP datagram trains, perfect to be coalesced into a single large segmented UDP datagram when Firefox receives it.
Why would Window&rsquo;s <code>URO</code> prevent Firefox from loading the site?</p>
<p>After many hours of back and forth with the reporter, luckily a Mozilla employee as well, I ended up buying the exact same laptop, <strong>same color</strong>, in a desperate attempt to reproduce the issue.
Without much luck at first, I eventually needed a Linux command line tool, thus installed WSL, and to my surprise, that triggered the bug (<a href="https://github.com/quinn-rs/quinn/issues/2041#issuecomment-2495419003">reproducer</a>).
Turns out, on Windows on ARM, with WSL enabled, a <code>WSARecvMsg</code> call with <code>URO</code> would not return a segment size, thus Firefox was unable to differentiate a single datagram, from a single segmented datagram.
QUIC short header packets don&rsquo;t carry a length, thus there is no way to tell where one QUIC packet ends and another starts, leading to the above page load failures.</p>
<p>We have been in touch with Microsoft since.
No progress thus far.
Thereby we are keeping <a href="https://github.com/quinn-rs/quinn/pull/2092"><code>URO</code> on Windows disabled</a> in Firefox for now.</p>
<p>After <code>URO</code> we started using <code>WSASendMsg</code> <code>USO</code>, i.e. sending a single large segmented datagram per system call.
But this too we rolled back quickly, seeing <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1979279">increased packet loss on Firefox Windows installations</a>.
In addition, we have at least one report of a user, seeing their network driver crash <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1978821">due to Firefox&rsquo;s usage of <code>USO</code></a>.
More debugging needed.</p>
<h3 id="macos">MacOS<a hidden class="anchor" aria-hidden="true" href="#macos">#</a></h3>
<p>The transition on MacOS from NSPR to quinn-udp for HTTP/3 QUIC UDP I/O involved switching from the system calls <code>sendto</code> and <code>recvfrom</code> to the system calls <code>sendmsg</code> and <code>recvmsg</code>.
As with Windows, no issues on this first step, ignoring one <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1987606">report</a> where MacOS 10.15 might be seeing <a href="https://github.com/quinn-rs/quinn/pull/2387">IP packets other than v4 and v6</a> (fixed since).</p>
<p>Unfortunately MacOS does not offer UDP segmentation offloading, neither on the send, nor on the receive side.
What it does offer though are two undocumented system calls, namely <a href="https://github.com/apple-oss-distributions/xnu/blob/94d3b452840153a99b38a3a9659680b2a006908e/bsd/sys/socket.h#L1457-L1487"><code>sendmsg_x</code></a> and <a href="https://github.com/apple-oss-distributions/xnu/blob/94d3b452840153a99b38a3a9659680b2a006908e/bsd/sys/socket.h#L1425-L1455"><code>recvmsg_x</code></a>, allowing a user to send and receive batches of UDP datagrams at once.
Lars from Mozilla added it to quinn-udp, exposed behind the <code>fast-apple-datapath</code> feature flag, off by default.
After multiple iterations with smaller bugfixes (<a href="https://github.com/quinn-rs/quinn/pull/2154">#2154</a>, <a href="https://github.com/quinn-rs/quinn/issues/2214">#2214</a>, <a href="https://github.com/quinn-rs/quinn/pull/2216">#2216</a> &hellip;) we decided to <a href="https://github.com/mozilla/neqo/pull/2638">not ship it to users</a>, not knowing how MacOS would behave, in case Apple ever decides to remove it, but with Firefox still calling it.</p>
<h3 id="linux">Linux<a hidden class="anchor" aria-hidden="true" href="#linux">#</a></h3>
<p>Linux provides the most comprehensive and mature UDP optimization support, offering both multi-message APIs (<code>sendmmsg</code>/<code>recvmmsg</code>) and segmentation offloading (GSO/GRO).
The quinn-udp library makes a deliberate choice to <a href="https://github.com/quinn-rs/quinn/pull/1729#issuecomment-1866939467">prioritize GSO over <code>sendmmsg</code></a> for transmission, as GSO typically provides superior performance with diminishing returns when both techniques are combined.
Thus far, this has proven the right choice for Firefox as well.</p>
<p>In addition to segmentation offloading being superior in the first place, Firefox uses one UDP socket per connection in order to improve privacy.
As each socket gets its own source port it is harder to correlate connections.
Why is this relevant here?
<code>GSO</code> (and <code>GRO</code>) can only segment (and coalesce) datagrams from the same 4-tuple (src IP, src port, dst IP, dst port), <code>sendmmsg</code> and <code>recvmmsg</code> on the other hand can send and receive across 4-tuples.
Given that Firefox uses one socket per connection, it cannot make use of that distinct benefit of <code>sendmmsg</code> (and <code>recvmmsg</code>), making segmentation offloading yet again the obvious choice for Firefox.</p>
<p>Ignoring minor changes required to <a href="https://hg-edge.mozilla.org/integration/autoland/rev/5f3a2655d2f4">Firefox&rsquo;s optional network sandboxing</a>, and an additional at runtime <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1989895">GSO support check</a>, replacing Firefox&rsquo;s QUIC UDP I/O stack on Linux has been without issues, now enjoying all the benefits of segmentation offloading.</p>
<h3 id="android">Android<a hidden class="anchor" aria-hidden="true" href="#android">#</a></h3>
<p>During the time of this project I learned quickly that (a) Android is not Linux and (b) that <a href="https://support.mozilla.org/en-US/kb/will-firefox-work-my-mobile-device">Firefox still supports Android 5</a>, &hellip;, on x86 (32 bit).</p>
<p>On x86, <a href="https://github.com/quinn-rs/quinn/pull/1964">Android dispatches advanced socket calls through <code>socketcall</code> system call</a> instead of calling e.g. <code>sendmsg</code> directly.
In addition Android has various default seccomp filters, crashing an app when e.g. not going through the required <code>socketcall</code> system call.
<a href="https://github.com/quinn-rs/quinn/pull/1966">The combination of the two</a> did cost me a couple of days, resulting in <a href="https://github.com/quinn-rs/quinn/pull/1966">this (basically single line) change in quinn-udp</a>.</p>
<p>On Android API level 25 and below, calling <code>sendmsg</code> with an ECN bit set <a href="https://github.com/quinn-rs/quinn/pull/1975">results in an error <code>EINVAL</code></a>.
<a href="https://github.com/quinn-rs/quinn/pull/2079">quinn-udp will now simply retry on <code>EINVAL</code></a> disabling various optional settings (e.g. ECN) on the second attempt.</p>
<p>Great benefit of the Quinn community is that Firefox will benefit from any improvements made to quinn-udp.
For example <a href="https://github.com/quinn-rs/quinn/pull/2050">this excellent find by Thomas</a> where Android in some cases would complain if we did a <code>GSO</code> with a single segment only.</p>
<h2 id="explicit-congestion-notifications-ecn">Explicit congestion notifications (ECN)<a hidden class="anchor" aria-hidden="true" href="#explicit-congestion-notifications-ecn">#</a></h2>
<p>With Firefox using modern system calls across all major operating systems, a nice additional benefit is the ability to send and receive ancillary data like <a href="https://en.wikipedia.org/wiki/Explicit_Congestion_Notification">IP ECN</a>.
This too <a href="https://github.com/quinn-rs/quinn/pull/1765">came with some minor surprises</a>, but QUIC ECN in Firefox is well on its way now.
Firefox Nightly telemetry shows around <a href="https://glam.telemetry.mozilla.org/fog/probe/networking_http_3_ecn_path_capability/explore?">50% of all QUIC connections running on ECN outbound capable paths</a>.
With <a href="https://datatracker.ietf.org/doc/rfc9330/">L4S</a> and thus ECN becoming more and more relevant in today&rsquo;s Internet, this is a great step forward.</p>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>We successfully replaced Firefox&rsquo;s QUIC UDP I/O stack with a modern memory-safe implementation using quinn-udp.
Instead of limited and dated system calls like <code>sendto</code> and <code>recvfrom</code>, Firefox now uses modern OS specific system calls across all major platforms, resulting in HTTP/3 QUIC throughput improvements when CPU bound, and enabling QUIC ECN support across all major platforms.
Some OS specific optimizations still need more work, e.g. <code>USO</code> and <code>URO</code> on Windows.
That said, especially given QUIC&rsquo;s growing adoption and thus increased UDP usage, I am optimistic that OS and driver support will continue to improve.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://max-inden.de/tags/tech/">Tech</a></li>
      <li><a href="https://max-inden.de/tags/quic/">Quic</a></li>
      <li><a href="https://max-inden.de/tags/firefox/">Firefox</a></li>
      <li><a href="https://max-inden.de/tags/rust/">Rust</a></li>
      <li><a href="https://max-inden.de/tags/networking/">Networking</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://max-inden.de/">Max Inden</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
